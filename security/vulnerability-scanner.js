#!/usr/bin/env node

/**
 * Comprehensive Security Vulnerability Scanner
 * Scans Next.js/PayloadCMS application for common security issues
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class SecurityScanner {
  constructor(rootDir) {
    this.rootDir = rootDir;
    this.vulnerabilities = [];
    this.scannedFiles = 0;
  }

  // Scan for hardcoded secrets and credentials
  scanSecrets(filePath, content) {
    const secretPatterns = [
      {
        name: 'Private Keys',
        pattern: /-----BEGIN [A-Z ]+-----[\s\S]*?-----END [A-Z ]+-----/gi,
        severity: 'CRITICAL'
      },
      {
        name: 'API Keys',
        pattern: /(api[_-]?key|apikey)[\s]*[=:]["']?[a-zA-Z0-9_-]{16,}["']?/gi,
        severity: 'HIGH'
      },
      {
        name: 'JWT Tokens',
        pattern: /eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/gi,
        severity: 'HIGH'
      },
      {
        name: 'Database Passwords',
        pattern: /(password|passwd|pwd)[\s]*[=:]["']?[^\s"']{8,}["']?/gi,
        severity: 'HIGH'
      },
      {
        name: 'AWS Secrets',
        pattern: /(AKIA|A3T|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}/gi,
        severity: 'CRITICAL'
      }
    ];

    secretPatterns.forEach(pattern => {
      const matches = content.match(pattern.pattern);
      if (matches) {
        matches.forEach(match => {
          this.addVulnerability({
            type: 'SECRET_EXPOSURE',
            severity: pattern.severity,
            file: filePath,
            line: this.getLineNumber(content, match),
            description: `${pattern.name} found in source code`,
            evidence: match.substring(0, 100) + '...',
            recommendation: 'Remove hardcoded secrets and use environment variables'
          });
        });
      }
    });
  }

  // Scan for XSS vulnerabilities
  scanXSS(filePath, content) {
    const xssPatterns = [
      {
        pattern: /dangerouslySetInnerHTML.*?(?!escapeHTML)/gi,
        description: 'Potentially unsafe HTML injection without escaping'
      },
      {
        pattern: /innerHTML\s*=\s*[^;]+/gi,
        description: 'Direct innerHTML assignment without sanitization'
      },
      {
        pattern: /eval\s*\(/gi,
        description: 'Use of eval() function can lead to code injection'
      },
      {
        pattern: /new\s+Function\s*\(/gi,
        description: 'Dynamic function creation can lead to code injection'
      }
    ];

    xssPatterns.forEach(pattern => {
      const matches = content.match(pattern.pattern);
      if (matches) {
        matches.forEach(match => {
          this.addVulnerability({
            type: 'XSS',
            severity: 'MEDIUM',
            file: filePath,
            line: this.getLineNumber(content, match),
            description: pattern.description,
            evidence: match,
            recommendation: 'Sanitize all user inputs and use secure alternatives'
          });
        });
      }
    });
  }

  // Scan for SQL injection vulnerabilities
  scanSQLInjection(filePath, content) {
    const sqlPatterns = [
      {
        pattern: /\$\{[^}]*\}.*?(SELECT|INSERT|UPDATE|DELETE)/gi,
        description: 'String interpolation in SQL queries can lead to injection'
      },
      {
        pattern: /"(SELECT|INSERT|UPDATE|DELETE).*?\+.*?"/gi,
        description: 'String concatenation in SQL queries'
      }
    ];

    sqlPatterns.forEach(pattern => {
      const matches = content.match(pattern.pattern);
      if (matches) {
        matches.forEach(match => {
          this.addVulnerability({
            type: 'SQL_INJECTION',
            severity: 'HIGH',
            file: filePath,
            line: this.getLineNumber(content, match),
            description: pattern.description,
            evidence: match,
            recommendation: 'Use parameterized queries or ORM methods'
          });
        });
      }
    });
  }

  // Scan for insecure configurations
  scanInsecureConfig(filePath, content) {
    if (filePath.includes('next.config.js') || filePath.includes('csp.js')) {
      // Check CSP policies
      if (content.includes("'unsafe-inline'") || content.includes("'unsafe-eval'")) {
        this.addVulnerability({
          type: 'INSECURE_CSP',
          severity: 'MEDIUM',
          file: filePath,
          line: this.getLineNumber(content, 'unsafe'),
          description: 'CSP allows unsafe inline scripts or eval',
          evidence: 'unsafe-inline or unsafe-eval detected',
          recommendation: 'Remove unsafe CSP directives and use nonces or hashes'
        });
      }
    }

    // Check for debug mode in production
    if (content.includes('console.log') && !filePath.includes('node_modules')) {
      this.addVulnerability({
        type: 'INFO_DISCLOSURE',
        severity: 'LOW',
        file: filePath,
        line: this.getLineNumber(content, 'console.log'),
        description: 'Console logging may expose sensitive information',
        evidence: 'console.log statement found',
        recommendation: 'Remove console.log statements in production'
      });
    }
  }

  // Scan for missing input validation
  scanInputValidation(filePath, content) {
    if (filePath.includes('endpoints/') || filePath.includes('route.ts')) {
      // Check if endpoints validate input
      if (content.includes('req.body') && !content.includes('validate') && !content.includes('joi') && !content.includes('zod')) {
        this.addVulnerability({
          type: 'MISSING_VALIDATION',
          severity: 'MEDIUM',
          file: filePath,
          line: this.getLineNumber(content, 'req.body'),
          description: 'API endpoint missing input validation',
          evidence: 'req.body usage without validation',
          recommendation: 'Implement input validation using joi, zod, or similar library'
        });
      }
    }
  }

  // Add vulnerability to list
  addVulnerability(vuln) {
    vuln.id = crypto.randomUUID();
    vuln.timestamp = new Date().toISOString();
    this.vulnerabilities.push(vuln);
  }

  // Get line number of match in content
  getLineNumber(content, match) {
    const index = content.indexOf(match);
    if (index === -1) return 1;
    return content.substring(0, index).split('\n').length;
  }

  // Scan a single file
  async scanFile(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      this.scannedFiles++;

      // Skip node_modules and build directories
      if (filePath.includes('node_modules') || filePath.includes('.next') || filePath.includes('dist')) {
        return;
      }

      // Run all scanners
      this.scanSecrets(filePath, content);
      this.scanXSS(filePath, content);
      this.scanSQLInjection(filePath, content);
      this.scanInsecureConfig(filePath, content);
      this.scanInputValidation(filePath, content);

    } catch (error) {
      console.error(`Error scanning ${filePath}: ${error.message}`);
    }
  }

  // Recursively scan directory
  async scanDirectory(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Skip certain directories
        if (!['node_modules', '.git', '.next', 'dist', 'build'].includes(entry.name)) {
          await this.scanDirectory(fullPath);
        }
      } else if (entry.isFile()) {
        // Scan relevant file types
        const ext = path.extname(entry.name);
        if (['.js', '.ts', '.tsx', '.jsx', '.json', '.env'].includes(ext)) {
          await this.scanFile(fullPath);
        }
      }
    }
  }

  // Generate vulnerability report
  generateReport() {
    const report = {
      summary: {
        totalFiles: this.scannedFiles,
        totalVulnerabilities: this.vulnerabilities.length,
        severityBreakdown: {
          critical: this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
          high: this.vulnerabilities.filter(v => v.severity === 'HIGH').length,
          medium: this.vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
          low: this.vulnerabilities.filter(v => v.severity === 'LOW').length
        }
      },
      vulnerabilities: this.vulnerabilities.sort((a, b) => {
        const severityOrder = { 'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      }),
      scanDate: new Date().toISOString()
    };

    return report;
  }

  // Run complete scan
  async scan() {
    console.log('🔍 Starting security vulnerability scan...');
    console.log(`📁 Scanning directory: ${this.rootDir}`);
    
    await this.scanDirectory(this.rootDir);
    
    const report = this.generateReport();
    
    console.log('\n📊 Scan Results:');
    console.log(`Files scanned: ${report.summary.totalFiles}`);
    console.log(`Vulnerabilities found: ${report.summary.totalVulnerabilities}`);
    console.log(`Critical: ${report.summary.severityBreakdown.critical}`);
    console.log(`High: ${report.summary.severityBreakdown.high}`);
    console.log(`Medium: ${report.summary.severityBreakdown.medium}`);
    console.log(`Low: ${report.summary.severityBreakdown.low}`);
    
    return report;
  }
}

// Export for use as module
module.exports = SecurityScanner;

// Command line usage
if (require.main === module) {
  const scanner = new SecurityScanner(process.argv[2] || '.');
  scanner.scan().then(report => {
    // Save report to file
    const reportPath = path.join(process.cwd(), 'security-scan-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(`\n📄 Report saved to: ${reportPath}`);
  }).catch(console.error);
}